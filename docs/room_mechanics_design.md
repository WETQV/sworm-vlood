# ТЗ: Логика Комнат, Дверей и Ботов (Вариант "А" - Мультиплеер)

Данный документ описывает правила поведения арен (боевых комнат) для корректной работы в рамках мультиплеера и защиты от эксплоитов (door-abusing).

---

## 1. Состояния Менеджера Комнаты (`room_manager.gd`)
Каждая сгенерированная боевая комната управляется собственным менеджером со следующими состояниями:

*   **SLEEP (Сон):**
    *   Враги сгенерированы, но их `process_mode` установлен в `PROCESS_MODE_DISABLED` (или кастомный стейт `IDLE`). Они не двигаются, не думают и не нагружают процессор.
    *   Выходы из комнаты (слоты коридоров) полностью открыты.
    *   Активна `Area2D` триггера (чуть меньше реальных размеров комнаты, чтобы случайное касание стены снаружи не запустило бой).
*   **FIGHT (Бой):**
    *   Запускается, когда центроид хотя бы одного игрока (`CharacterBody2D` из группы "players") пересекает триггер-зону комнаты.
    *   Все выходы блокируются **Односторонними Дверьми** (One-Way Doors).
    *   Менеджер вызывает метод `wake_up()` у всех врагов в комнате.
*   **CLEARED (Зачищено):**
    *   Наступает, когда счётчик `enemies_alive` достигает 0 (слушаем сигналы `died` от врагов).
    *   Двери навсегда удаляются (или отключается коллизия + проигрывается анимация исчезновения).
    *   Активируется спавн лута (например, анимация сундука).
    *   Комната больше ни на что не реагирует.

---

## 2. Механика Дверей и Отставших Игроков
В кооперативной игре частая ситуация — один игрок вбежал в комнату, а второй отстал (лутает сундук, откидывается в коридоре). Классические "закрывающиеся стены" отрезали бы игроков друг от друга.

**Решение:**
На местах выходов (по координатам `door_slots`) генерируются полупрозрачные барьеры (например, магические стены).
1.  **Свойство One-Way Collision:** `true`. Направление коллизии смотрит *внутрь* комнаты.
2.  **Эффект:** Игрок, находящийся снаружи (в коридоре), может спокойно пройти сквозь дверь на помощь товарищу. Однако выйти обратно в коридор никто (ни игроки, ни монстры) не сможет до окончания боя.

---

## 3. Защита от эксплоитов (Анти-Абуз)
Существует критический эксплоит: классы дальнего боя (Маг, Лучник) могут подойти к односторонней двери так, что их модель будет наполовину в коридоре, наполовину в комнате (коллизия не вытолкнет их наружу полностью). Оттуда они смогут безнаказанно расстреливать "проснувшихся" мобов, так как мобы не смогут выйти за барьер.

**Решение: Зона Вталкивания (Push-in Zone):**
*   Для каждой двери, на 1 тайл *вглубь* комнаты, размещается невидимый триггер (или используется функционал самого барьера с фантомной зоной формы тела).
*   Как только центр коллизии игрока пересекает линию двери (т.е. он подтверждает своё намерение зайти), срабатывает скрипт.
*   Скрипт принудительно (через интерполяцию `Tween` или контролируемое смещение `move_and_collide`) сдвигает игрока на 1-2 тайла вглубь комнаты.
*   **Итог:** Попытка "встать в текстурах двери" карается немедленным переносом внутрь арены без возможности выхода. Игроку придётся принять бой по правилам.

---

## 4. ИИ и Навигация Врагов
Чтобы враги не застревали в колоннах или ямах (если таковые будут в дизайне `room_combat_large`):
*   Используем **NavigationAgent2D** (Godot 2D Navigation Server).
*   Так как бой происходит в замкнутом периметре комнаты с закрытыми дверями, отпадает необходимость сложного поиска пути по всему подземелью (на что уходила бы львиная доля ресурсов).
*   Всё, что нужно сделать NavigationServer’у — найти путь внутри небольшого локального прямоугольника (или полигона) конкретной комнаты к ближайшему игроку. Это крайне производительно.

---

## 5. Порталы и Переход между Этажами
Для системы прогрессии после зачистки комнаты с боссом:
1.  **Точка спавна:** В центре комнаты Босса (уже на этапе процедурной генерации) резервируется `Marker2D` с классом `SpawnPoint` и типом `PORTAL`.
2.  **Активация:** При смерти босса, на месте этого маркера инстанцируется сцена `portal.tscn`.
3.  **Синхронизация по сети:** 
    *   Когда игрок взаимодействует с порталом, открывается локальный/глобальный UI (например: "Переход на следующий этаж: 1/2 игроков").
    *   Узел `NetworkManager` собирает RPC-отзывы ("Готов") от всех клиентов.
    *   Когда все (или большинство) подтвердили переход, **Хост** вызывает метод `GameManager.next_floor()`.
    *   Хост генерирует новый `seed` подземелья, инкрементирует счётчик этажа, увеличивает `difficulty_multiplier` (множитель здоровья и урона монстров) и через `rpc("load_floor", new_seed, new_stats)` приказывает всем клиентам синхронно перезагрузить сцену уровня с новыми вводными.
